题意：
N个数，取m个不想交的子序列，求和最大值

分析：
设dp[i][j] 为前j项得到i个不相交子序列的最大值，强制最后一个子序列以a[j]结尾
dp[i][j] = max {dp[i][j-1],dp[i-1][t]}+a[j]  (i-1<=t<=j-1)
最后结果为 dp[m][k] (1<=k<=n)
n非常大，m未知。朴素的计算时间复杂度O(M*N^2),空间复杂度O(M*N)，不可接受

优化：
(1)时间：
定义pre数组，pre[j-1] 代表dp[i-1][t]最大值，所以pre[n]用不上，可以用来存储其他有用的值
求解dp[i][j],也计算出了dp[i][t] (1<=t<=j) 最大值，可以用来求dp[i+1][j+1]，暂存为pre[n]
求解了dp[i][j+1]过后,再把pre[j]更新为pre[n]
时间复杂度为O(N^2)
(2)空间：
pre[n]即为最后结果，所以不必开一个M*N的DP数组
